/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 *  Tokenizer layers.
 */
/* Original source: keras-nlp/tokenizer.py */
import { serialization, tensor, tidy } from '@tensorflow/tfjs-core';
import { Layer } from '../../engine/topology';
import { NotImplementedError, ValueError } from '../../errors';
import { BytePairTokenizerCache, bytesToUnicode, createStaticHashtable, removeStringsFromInputs, splitStringsForBpe } from './tokenizers_utils';
import { tensorToArr, tensorArrTo2DArr } from './utils';
/**
 * Base class for Tokenizers.
 *
 *  Tokenizers in the tfjs library should all subclass this layer.
 *  The class provides two core methods `tokenize()` and `detokenize()` for
 *  going from plain text to sequences and back. A tokenizer is a subclass of
 *  `Layer` and can be combined with other layers in a `tf.sequential` model.
 *
 *  Subclassers should always implement the `tokenize()` method, which will also
 *  be the default when calling the layer directly on inputs.
 *
 *  Subclassers can optionally implement the `detokenize()` method if the
 *  tokenization is reversible. Otherwise, this can be skipped.
 *
 *  Subclassers should implement `get_vocabulary()`, `vocabulary_size()`,
 *  `token_to_id()` and `id_to_token()` if applicable. For some simple
 *  "vocab free" tokenizers, such as a whitespace splitter shown below, these
 *  methods do not apply and can be skipped.
 *
 *  Example:
 *
 *  ```js
 *  class WhitespaceSplitterTokenizer extends Tokenizer {
 *    tokenize(inputs: Tensor): Tensor[] {
 *      const stringInputs = inputs.dataSync() as unknown as string[];
 *      return stringInputs.map(input => Tensor(input.split(' ')));
 *    }
 *
 *    override detokenize(inputs: Tensor[]): Tensor {
 *      const stringInputs = inputs.map(
 *        input => input.dataSync() as unknown as string[]);
 *      return Tensor(stringInputs.map(str => str.join(' ')));
 *    }
 *  }
 *
 * const tokenizer = new WhitespaceSplitterTokenizer();
 *
 * tokenizer.tokenize(tensor(['this is a test']))[0].print();
 *
 * tokenizer.detokenize([tensor(['this', 'is', 'a', 'test'])]).print();
 * ```
 */
export class Tokenizer extends Layer {
    /**
     * Transform tokens back into strings.
     *
     * @param inputs Input tensor.
     * @param kwargs Additional keyword arguments.
     */
    detokenize(inputs) {
        throw new NotImplementedError(`No implementation of 'detokenize()' was found for
      ${this.constructor.name}.`);
    }
    /**
     * Get the tokenizer vocabulary as a list of strings terms.
     */
    get vocabulary() {
        throw new NotImplementedError(`No implementation of 'vocabulary()' was found for
      ${this.constructor.name}.`);
    }
    /**
     * Returns the total size of the token id space.
     */
    get vocabularySize() {
        throw new NotImplementedError(`No implementation of 'vocabularySize()' was found for
      ${this.constructor.name}.`);
    }
    /**
     * Convert an integer id to a string token.
     */
    idToToken(id) {
        throw new NotImplementedError(`No implementation of 'idToToken()' was found for
      ${this.constructor.name}.`);
    }
    /**
     * Convert an integer id to a string token.
     */
    tokenToId(token) {
        throw new NotImplementedError(`No implementation of 'tokenToId()' was found for
      ${this.constructor.name}.`);
    }
    call(inputs, { mode = 'tokenize' } = {}) {
        if (mode === 'tokenize') {
            if (inputs instanceof Array) {
                throw new ValueError(`tokenize expects Tensor, not Tensor[].`);
            }
            return this.tokenize(inputs);
        }
        if (mode === 'detokenize') {
            if (!(inputs instanceof Array)) {
                throw new ValueError(`detokenize expects Tensor[], not Tensor.`);
            }
            return this.detokenize(inputs);
        }
        throw new ValueError(`Input mode=${mode} is not supported.`);
    }
}
/**
 * Byte-pair encoding tokenizer layer.
 *
 * This BPE tokenizer provides the same functionality as the official GPT-2
 * tokenizer. Given the same `vocabulary` which maps tokens to ids, and `merges`
 * which describes BPE merge rules, it should provide the same output as OpenAI
 * implementation (https://github.com/openai/gpt-2/blob/master/src/encoder.py).
 *
 * If input is a batch of strings (rank > 0):
 * By default, the layer will output a `Tensor[]`.
 * If `sequenceLength` is set, the layer will output a `Tensor[]` where all
 * inputs have been padded or truncated to `sequenceLength`.
 *
 * Examples:
 *
 * Tokenize
 * ```js
 * const vocabulary = new Map([['butter', 1], ['fly', 2]]);
 * const merges = ['b u', 't t', 'e r', 'bu tt', 'butt er', 'f l', 'fl y'];
 * const tokenizer = new BytePairTokenizer({vocabulary, merges});
 *
 * tokenizer.tokenize(tensor(['butterfly']))[0].print();
 * tokenizer.tokenize(tensor(['butterfly, butter']))[1].print();
 * ```
 *
 * Detokenize
 * ```js
 * const vocabulary = new Map([['butter', 1], ['fly', 2]]);
 * const merges = ['b u', 't t', 'e r', 'bu tt', 'butt er', 'f l', 'fl y'];
 * const tokenizer = new BytePairTokenizer({vocabulary, merges});
 *
 * tokenizer.detokenize([[1, 2]]).print();
 * ```
 */
export class BytePairTokenizer extends Tokenizer {
    constructor(args) {
        super(args);
        this.cache = new BytePairTokenizerCache();
        this._vocabulary = new Map(args.vocabulary);
        this.merges = [...args.merges];
        this.sequenceLength = args.sequenceLength || null;
        this.addPrefixSpace = args.addPrefixSpace || false;
        this.unsplittableTokens = args.unsplittableTokens || null;
        // Create byte <=> unicode mapping. This is useful for handling
        // whitespace tokens.
        const [byteList, unicodeList] = bytesToUnicode();
        this.byte2Unicode = createStaticHashtable(Array.from(byteList), unicodeList, '');
        if (this.unsplittableTokens) {
            // Put unsplittable tokens into cache, so it won't be further split and
            // merged.
            this.cache.insert(this.unsplittableTokens, this.unsplittableTokens);
        }
        // Create mapping between string tokens to int ids, and vice versa.
        const bytePairs = [...this._vocabulary.keys()];
        const bytePairEncodingIndicies = [...this._vocabulary.values()];
        this.tokenToIdMap = createStaticHashtable(bytePairs, bytePairEncodingIndicies, -1);
        this.idToTokenMap = createStaticHashtable(bytePairEncodingIndicies, bytePairs, '');
        // Create ranking of merge rules, this is the same as order of merge pairs
        // in `this.merges`.
        this.mergeRanksLookupDefault = this.merges.length + 1;
        this.mergeRanks = createStaticHashtable(this.merges, [...Array(this.merges.length).keys()], this.mergeRanksLookupDefault);
    }
    /**
     * Get the tokenizer vocabulary as a list of string tokens.
     */
    get vocabulary() {
        return [...this._vocabulary.keys()];
    }
    /**
     * Get the size of the tokenizer vocabulary.
     */
    get vocabularySize() {
        return this._vocabulary.size;
    }
    /**
     * Convert an integer id to a string token.
     */
    idToToken(id) {
        // This will be slow, but keep memory usage down compared to building a
        // dict. Assuming the main use case is looking up a few special tokens
        // early in the vocab, this should be fine.
        const keys = this.vocabulary;
        for (const token of keys) {
            if (this._vocabulary.get(token) === id) {
                return token;
            }
        }
        return undefined;
    }
    /**
     * Convert a string token to an integer id.
     */
    tokenToId(token) {
        return this._vocabulary.get(token);
    }
    getConfig() {
        const config = {
            vocabulary: this.vocabulary,
            merges: this.merges,
            sequenceLength: this.sequenceLength,
            addPrefixSpace: this.addPrefixSpace,
            unsplittableTokens: this.unsplittableTokens,
        };
        const baseConfig = super.getConfig();
        Object.assign(config, baseConfig);
        return config;
    }
    /**
     * Perform one step of byte-pair merge.
     */
    bpeMergeOneStep(words, mask) {
        const wordsStr = tensorArrTo2DArr(words);
        // Get all word pairs.
        const first = wordsStr.map(arr => arr.slice(0, -1));
        const second = wordsStr.map(arr => arr.slice(1, arr.length));
        // Mask empty.
        const nonEmptyMask = second.map(arr => arr.length > 0);
        mask = mask.map((a, idx) => a && nonEmptyMask[idx]);
        if (!mask.some(e => e)) {
            return [words, mask];
        }
        const nonEmptyIndices = mask
            .map((bool, idx) => bool ? idx : -1)
            .filter(e => e !== -1);
        const filteredFirst = nonEmptyIndices.map(idx => first[idx]);
        const filteredSecond = nonEmptyIndices.map(idx => second[idx]);
        // Get byte pair ranking in merge rules.
        const pairs = filteredFirst.map((firstSubArr, idx) => {
            const secondSubArr = filteredSecond[idx];
            return firstSubArr.map((char, idx) => `${char} ${secondSubArr[idx]}`);
        });
        const pairRanksTensor = this.mergeRanks.lookup(pairs.map(arr => tensor(arr)));
        const pairRanks = tensorArrTo2DArr(pairRanksTensor);
        // Get BPE pair ranks.
        const minPairRank = pairRanks.map(arr => arr.reduce((a, b) => Math.min(a, b), Infinity));
        const pairFoundMask = minPairRank.map(rank => rank !== this.mergeRanksLookupDefault);
        // Tokens that cannot be further merged are marked as finished.
        for (const [idx, index] of nonEmptyIndices.entries()) {
            const update = pairFoundMask[idx];
            mask[index] = update;
        }
        if (!mask.some(e => e)) {
            return [words, mask];
        }
        function argMin(arr) {
            return arr.indexOf(arr.reduce((a, b) => Math.min(a, b), Infinity));
        }
        const maskedPairRanks = pairRanks.filter((_, idx) => pairFoundMask[idx]);
        const minPairRankIndices = maskedPairRanks.map(arr => argMin(arr));
        // Get words and pairs to process.
        const unfinishedWords = wordsStr.filter((_, idx) => mask[idx]);
        const pairLeft = unfinishedWords.map((word, idx) => word[minPairRankIndices[idx]]);
        const pairRight = unfinishedWords.map((word, idx) => word[minPairRankIndices[idx] + 1]);
        const mergedPairs = pairLeft.map((left, idx) => {
            const right = pairRight[idx];
            return `${left}${right}`;
        });
        const unfinishedWordsIndices = mask
            .map((_, idx) => idx)
            .filter((_, idx) => mask[idx]);
        const mergedPairIndices = unfinishedWordsIndices.map((index, idx) => [index, minPairRankIndices[idx]]);
        const emptyStringIndices = unfinishedWordsIndices.map((index, idx) => [index, minPairRankIndices[idx] + 1]);
        for (const [idx, indices] of mergedPairIndices.entries()) {
            const [wordIdx, charIdx] = indices;
            const mergedPair = mergedPairs[idx];
            wordsStr[wordIdx][charIdx] = mergedPair;
        }
        for (const indices of emptyStringIndices) {
            const [wordIdx, charIdx] = indices;
            wordsStr[wordIdx][charIdx] = '';
        }
        words = wordsStr.map(word => tensor(word));
        words = removeStringsFromInputs(words, '');
        return [words, mask];
    }
    /**
     * Perform byte-pair merge for each word in the inputs.
     */
    bpeMerge(words) {
        const numWords = words.length;
        // Merge bytes.
        function loopCondition(mask) {
            return mask.some(e => e);
        }
        const initialMask = Array(numWords).fill(true);
        let mergedWords = words;
        let mask = initialMask;
        while (loopCondition(mask)) {
            [mergedWords, mask] = this.bpeMergeOneStep(mergedWords, mask);
        }
        return mergedWords;
    }
    /**
     * Map token bytes to unicode using `byte2unicode`.
     */
    transformBytes(tokens) {
        const tokensStr = tensorToArr(tokens);
        const splitBytes = tokensStr.map(token => tensor(token.split('').map(c => c.charCodeAt(0))));
        const splitUnicode = this.byte2Unicode.lookup(splitBytes);
        return splitUnicode;
    }
    /**
     * Process unseen tokens and add to cache.
     */
    bpeMergeAndUpdateCache(tokens) {
        const words = this.transformBytes(tokens);
        const tokenizedWordsTensor = this.bpeMerge(words);
        const tokenizedWords = tensorArrTo2DArr(tokenizedWordsTensor);
        // For each word, join all its token by a whitespace,
        // e.g., ["dragon", "fly"] => "dragon fly" for hash purpose.
        const joinedTokens = tokenizedWords.map(word => word.join(' '));
        this.cache.insert(tokens, joinedTokens);
    }
    tokenize(inputs) {
        return tidy(() => {
            if (this.addPrefixSpace) {
                const strInputs = tensorToArr(inputs);
                inputs = tensor(strInputs.map(word => ' ' + word));
            }
            const rawTokensTensor = splitStringsForBpe(inputs, this.unsplittableTokens);
            const rawTokens = tensorArrTo2DArr(rawTokensTensor);
            const tokenRowSplits = [0];
            for (const [idx, token] of rawTokens.entries()) {
                tokenRowSplits.push(tokenRowSplits[idx] + token.length);
            }
            const flatTokens = rawTokens.reduce((acc, e) => acc.concat(e), []);
            // Check cache.
            const cacheLookup = this.cache.lookup(flatTokens);
            const cacheMask = cacheLookup.map(e => e === '');
            const hasUnseenWords = cacheMask.some((bool, idx) => bool && flatTokens[idx] !== '');
            const processUnseenTokens = () => {
                const unseenTokens = flatTokens.filter((_, idx) => cacheMask[idx]);
                this.bpeMergeAndUpdateCache(tensor(unseenTokens));
                return this.cache.lookup(flatTokens);
            };
            // If `has_unseen_words == True`, it means not all tokens are in cache,
            // we will process the unseen tokens. Otherwise return the cache lookup.
            const tokenizedWords = hasUnseenWords ? processUnseenTokens() : cacheLookup;
            const tokensTensor = this.tokenToIdMap.lookup(tokenizedWords.map(word => tensor(word.split(' '))));
            const tokens = tokensTensor.map(t => Array.from(t.dataSync()));
            // Unflatten to match input.
            const newTokenRowSplits = [0];
            for (const [idx, token] of tokens.entries()) {
                newTokenRowSplits.push(newTokenRowSplits[idx] + token.length);
            }
            const newFlatTokens = tokens.reduce((acc, e) => acc.concat(e), []);
            const gatheredIndices = tokenRowSplits.map(index => newTokenRowSplits[index]);
            let tokens2D = [];
            for (let i = 0; i < gatheredIndices.length - 1; i++) {
                const [start, end] = [gatheredIndices[i], gatheredIndices[i + 1]];
                const row = newFlatTokens.slice(start, end);
                tokens2D.push(tensor(row));
            }
            // Convert to a dense output if `sequenceLength` is set.
            if (this.sequenceLength) {
                // pad or truncate
                tokens2D = tokens2D.map(t => {
                    if (t.size === this.sequenceLength) {
                        return t;
                    }
                    else if (t.size > this.sequenceLength) {
                        return t.slice(0, this.sequenceLength);
                    }
                    else {
                        return t.pad([[0, this.sequenceLength - t.size]]);
                    }
                });
            }
            return tokens2D;
        });
    }
    detokenize(inputs) {
        const unicodeText = this.idToTokenMap.lookup(inputs)
            .map(t => tensorToArr(t).join(''));
        return tensor(unicodeText);
    }
}
/** @nocollapse */
BytePairTokenizer.className = 'BytePairTokenizer';
serialization.registerClass(BytePairTokenizer);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5pemVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvbmxwL3Rva2VuaXplcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUg7O0dBRUc7QUFFSCw2Q0FBNkM7QUFDN0MsT0FBTyxFQUFVLGFBQWEsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFM0UsT0FBTyxFQUFFLEtBQUssRUFBYSxNQUFNLHVCQUF1QixDQUFDO0FBQ3pELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxVQUFVLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDL0QsT0FBTyxFQUFFLHNCQUFzQixFQUFtQixjQUFjLEVBQUUscUJBQXFCLEVBQUUsdUJBQXVCLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNqSyxPQUFPLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBTXhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlDRztBQUNILE1BQU0sT0FBZ0IsU0FBVSxTQUFRLEtBQUs7SUFTM0M7Ozs7O09BS0c7SUFDSCxVQUFVLENBQUMsTUFBZ0I7UUFDekIsTUFBTSxJQUFJLG1CQUFtQixDQUMzQjtRQUNFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLENBQzNCLENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLFVBQVU7UUFDWixNQUFNLElBQUksbUJBQW1CLENBQzNCO1FBQ0UsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsQ0FDM0IsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksY0FBYztRQUNoQixNQUFNLElBQUksbUJBQW1CLENBQzNCO1FBQ0UsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJ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RTt3QkFDbEMsT0FBTyxDQUFDLENBQUM7cUJBQ1Y7eUJBQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUU7d0JBQ3ZDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO3FCQUN4Qzt5QkFBTTt3QkFDTCxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQ25EO2dCQUNILENBQUMsQ0FBQyxDQUFDO2FBQ0o7WUFFRCxPQUFPLFFBQVEsQ0FBQztRQUNsQixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFUSxVQUFVLENBQUMsTUFBZ0I7UUFDbEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO2FBQ2pELEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFFLFdBQVcsQ0FBQyxDQUFDLENBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVuRCxPQUFPLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM3QixDQUFDOztBQWhWRCxrQkFBa0I7QUFDRiwyQkFBUyxHQUFHLG1CQUFtQixDQUFDO0FBaVZsRCxhQUFhLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogIFRva2VuaXplciBsYXllcnMuXG4gKi9cblxuLyogT3JpZ2luYWwgc291cmNlOiBrZXJhcy1ubHAvdG9rZW5pemVyLnB5ICovXG5pbXBvcnQgeyBUZW5zb3IsIHNlcmlhbGl6YXRpb24sIHRlbnNvciwgdGlkeX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHsgTGF5ZXIsIExheWVyQXJncyB9IGZyb20gJy4uLy4uL2VuZ2luZS90b3BvbG9neSc7XG5pbXBvcnQgeyBOb3RJbXBsZW1lbnRlZEVycm9yLCBWYWx1ZUVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEJ5dGVQYWlyVG9rZW5pemVyQ2FjaGUsIFN0YXRpY0hhc2hUYWJsZSwgYnl0ZXNUb1VuaWNvZGUsIGNyZWF0ZVN0YXRpY0hhc2h0YWJsZSwgcmVtb3ZlU3RyaW5nc0Zyb21JbnB1dHMsIHNwbGl0U3RyaW5nc0ZvckJwZSB9IGZyb20gJy4vdG9rZW5pemVyc191dGlscyc7XG5pbXBvcnQgeyB0ZW5zb3JUb0FyciwgdGVuc29yQXJyVG8yREFyciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgVG9rZW5pemVyT3B0aW9ucyB7XG4gIG1vZGU/OiAndG9rZW5pemUnIHwgJ2RldG9rZW5pemUnO1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFRva2VuaXplcnMuXG4gKlxuICogIFRva2VuaXplcnMgaW4gdGhlIHRmanMgbGlicmFyeSBzaG91bGQgYWxsIHN1YmNsYXNzIHRoaXMgbGF5ZXIuXG4gKiAgVGhlIGNsYXNzIHByb3ZpZGVzIHR3byBjb3JlIG1ldGhvZHMgYHRva2VuaXplKClgIGFuZCBgZGV0b2tlbml6ZSgpYCBmb3JcbiAqICBnb2luZyBmcm9tIHBsYWluIHRleHQgdG8gc2VxdWVuY2VzIGFuZCBiYWNrLiBBIHRva2VuaXplciBpcyBhIHN1YmNsYXNzIG9mXG4gKiAgYExheWVyYCBhbmQgY2FuIGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgbGF5ZXJzIGluIGEgYHRmLnNlcXVlbnRpYWxgIG1vZGVsLlxuICpcbiAqICBTdWJjbGFzc2VycyBzaG91bGQgYWx3YXlzIGltcGxlbWVudCB0aGUgYHRva2VuaXplKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBhbHNvXG4gKiAgYmUgdGhlIGRlZmF1bHQgd2hlbiBjYWxsaW5nIHRoZSBsYXllciBkaXJlY3RseSBvbiBpbnB1dHMuXG4gKlxuICogIFN1YmNsYXNzZXJzIGNhbiBvcHRpb25hbGx5IGltcGxlbWVudCB0aGUgYGRldG9rZW5pemUoKWAgbWV0aG9kIGlmIHRoZVxuICogIHRva2VuaXphdGlvbiBpcyByZXZlcnNpYmxlLiBPdGhlcndpc2UsIHRoaXMgY2FuIGJlIHNraXBwZWQuXG4gKlxuICogIFN1YmNsYXNzZXJzIHNob3VsZCBpbXBsZW1lbnQgYGdldF92b2NhYnVsYXJ5KClgLCBgdm9jYWJ1bGFyeV9zaXplKClgLFxuICogIGB0b2tlbl90b19pZCgpYCBhbmQgYGlkX3RvX3Rva2VuKClgIGlmIGFwcGxpY2FibGUuIEZvciBzb21lIHNpbXBsZVxuICogIFwidm9jYWIgZnJlZVwiIHRva2VuaXplcnMsIHN1Y2ggYXMgYSB3aGl0ZXNwYWNlIHNwbGl0dGVyIHNob3duIGJlbG93LCB0aGVzZVxuICogIG1ldGhvZHMgZG8gbm90IGFwcGx5IGFuZCBjYW4gYmUgc2tpcHBlZC5cbiAqXG4gKiAgRXhhbXBsZTpcbiAqXG4gKiAgYGBganNcbiAqICBjbGFzcyBXaGl0ZXNwYWNlU3BsaXR0ZXJUb2tlbml6ZXIgZXh0ZW5kcyBUb2tlbml6ZXIge1xuICogICAgdG9rZW5pemUoaW5wdXRzOiBUZW5zb3IpOiBUZW5zb3JbXSB7XG4gKiAgICAgIGNvbnN0IHN0cmluZ0lucHV0cyA9IGlucHV0cy5kYXRhU3luYygpIGFzIHVua25vd24gYXMgc3RyaW5nW107XG4gKiAgICAgIHJldHVybiBzdHJpbmdJbnB1dHMubWFwKGlucHV0ID0+IFRlbnNvcihpbnB1dC5zcGxpdCgnICcpKSk7XG4gKiAgICB9XG4gKlxuICogICAgb3ZlcnJpZGUgZGV0b2tlbml6ZShpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yIHtcbiAqICAgICAgY29uc3Qgc3RyaW5nSW5wdXRzID0gaW5wdXRzLm1hcChcbiAqICAgICAgICBpbnB1dCA9PiBpbnB1dC5kYXRhU3luYygpIGFzIHVua25vd24gYXMgc3RyaW5nW10pO1xuICogICAgICByZXR1cm4gVGVuc29yKHN0cmluZ0lucHV0cy5tYXAoc3RyID0+IHN0ci5qb2luKCcgJykpKTtcbiAqICAgIH1cbiAqICB9XG4gKlxuICogY29uc3QgdG9rZW5pemVyID0gbmV3IFdoaXRlc3BhY2VTcGxpdHRlclRva2VuaXplcigpO1xuICpcbiAqIHRva2VuaXplci50b2tlbml6ZSh0ZW5zb3IoWyd0aGlzIGlzIGEgdGVzdCddKSlbMF0ucHJpbnQoKTtcbiAqXG4gKiB0b2tlbml6ZXIuZGV0b2tlbml6ZShbdGVuc29yKFsndGhpcycsICdpcycsICdhJywgJ3Rlc3QnXSldKS5wcmludCgpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUb2tlbml6ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gaW5wdXQgdGVuc29ycyBvZiBzdHJpbmdzIGludG8gb3V0cHV0IHRva2Vucy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBJbnB1dCB0ZW5zb3IuXG4gICAqIEBwYXJhbSBrd2FyZ3MgQWRkaXRpb25hbCBrZXl3b3JkIGFyZ3VtZW50cy5cbiAgICovXG4gIGFic3RyYWN0IHRva2VuaXplKGlucHV0czogVGVuc29yKTogVGVuc29yW107XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0b2tlbnMgYmFjayBpbnRvIHN0cmluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dHMgSW5wdXQgdGVuc29yLlxuICAgKiBAcGFyYW0ga3dhcmdzIEFkZGl0aW9uYWwga2V5d29yZCBhcmd1bWVudHMuXG4gICAqL1xuICBkZXRva2VuaXplKGlucHV0czogVGVuc29yW10pOiBUZW5zb3Ige1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgYE5vIGltcGxlbWVudGF0aW9uIG9mICdkZXRva2VuaXplKCknIHdhcyBmb3VuZCBmb3JcbiAgICAgICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRva2VuaXplciB2b2NhYnVsYXJ5IGFzIGEgbGlzdCBvZiBzdHJpbmdzIHRlcm1zLlxuICAgKi9cbiAgZ2V0IHZvY2FidWxhcnkoKTogc3RyaW5nW10ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgYE5vIGltcGxlbWVudGF0aW9uIG9mICd2b2NhYnVsYXJ5KCknIHdhcyBmb3VuZCBmb3JcbiAgICAgICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBzaXplIG9mIHRoZSB0b2tlbiBpZCBzcGFjZS5cbiAgICovXG4gIGdldCB2b2NhYnVsYXJ5U2l6ZSgpOiBudW1iZXIge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgYE5vIGltcGxlbWVudGF0aW9uIG9mICd2b2NhYnVsYXJ5U2l6ZSgpJyB3YXMgZm91bmQgZm9yXG4gICAgICAke3RoaXMuY29uc3RydWN0b3IubmFtZX0uYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbiBpbnRlZ2VyIGlkIHRvIGEgc3RyaW5nIHRva2VuLlxuICAgKi9cbiAgaWRUb1Rva2VuKGlkOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgYE5vIGltcGxlbWVudGF0aW9uIG9mICdpZFRvVG9rZW4oKScgd2FzIGZvdW5kIGZvclxuICAgICAgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9LmBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gaW50ZWdlciBpZCB0byBhIHN0cmluZyB0b2tlbi5cbiAgICovXG4gIHRva2VuVG9JZCh0b2tlbjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgIGBObyBpbXBsZW1lbnRhdGlvbiBvZiAndG9rZW5Ub0lkKCknIHdhcyBmb3VuZCBmb3JcbiAgICAgICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS5gXG4gICAgKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGNhbGwoXG4gICAgaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sXG4gICAge21vZGUgPSAndG9rZW5pemUnfTogVG9rZW5pemVyT3B0aW9ucz17fVxuICApOiBUZW5zb3J8VGVuc29yW10ge1xuXG4gICAgaWYgKG1vZGUgPT09ICd0b2tlbml6ZScpIHtcbiAgICAgIGlmIChpbnB1dHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgdG9rZW5pemUgZXhwZWN0cyBUZW5zb3IsIG5vdCBUZW5zb3JbXS5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRva2VuaXplKGlucHV0cyk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09ICdkZXRva2VuaXplJykge1xuICAgICAgaWYgKCEoaW5wdXRzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBkZXRva2VuaXplIGV4cGVjdHMgVGVuc29yW10sIG5vdCBUZW5zb3IuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kZXRva2VuaXplKGlucHV0cyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYElucHV0IG1vZGU9JHttb2RlfSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICB9XG59XG5cbi8qIE9yaWdpbmFsIHNvdXJjZToga2VyYXMtbmxwL2J5dGVfcGFpcl90b2tlbml6ZXIucHkgKi9cbi8vIFRPRE8ocGZvcmRlcmlxdWUpOiBTdXBwb3J0IGZpbGVuYW1lIHN0cmluZyBpbnB1dHMgZm9yIHZvY2FidWxhcnkgYW5kIG1lcmdlcy5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBCeXRlUGFpclRva2VuaXplckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogTWFwcyB0b2tlbiB0byBpbnRlZ2VyIGlkc1xuICAgKi9cbiAgdm9jYWJ1bGFyeTogTWFwPHN0cmluZywgbnVtYmVyPjtcblxuICAvKipcbiAgICogQXJyYXkuIENvbnRhaW5zIHRoZSBtZXJnZSBydWxlLlxuICAgKi9cbiAgbWVyZ2VzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogSW50ZWdlci4gSWYgc2V0LCB0aGUgb3V0cHV0IHdpbGwgYmUgcGFkZGVkIG9yIHRydW5jYXRlZCB0byB0aGVcbiAgICogYHNlcXVlbmNlTGVuZ3RoYC4gRGVmYXVsdHMgdG8gYG51bGxgLlxuICAgKi9cbiAgc2VxdWVuY2VMZW5ndGg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEJvb2xlYW4uIFdoZXRoZXIgdG8gYWRkIGFuIGluaXRpYWwgc3BhY2UgdG8gdGhlIGlucHV0LiBUaGlzIHRva2VuaXplciBpc1xuICAgKiB3aGl0ZXNwYWNlIGF3YXJlLCBhbmQgd2lsbCB0b2tlbml6ZSBhIHdvcmQgd2l0aCBhIGxlYWRpbmcgc3BhY2VcbiAgICogZGlmZmVyZW50bHkuIEFkZGluZyBhIHByZWZpeCBzcGFjZSB0byB0aGUgZmlyc3Qgd29yZCB3aWxsIGNhdXNlIGl0IHRvIGJlXG4gICAqIHRva2VuaXplZCBlcXVpdmFsZW50bHkgdG8gYWxsIHN1YnNlcXVlbnQgd29yZHMgaW4gdGhlIHNlcXVlbmNlLlxuICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKi9cbiAgYWRkUHJlZml4U3BhY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBcnJheS4gQSBsaXN0IG9mIHN0cmluZ3MgdGhhdCB3aWxsIG5ldmVyIGJlIHNwbGl0IGR1cmluZyB0aGUgd29yZC1sZXZlbFxuICAgKiBzcGxpdHRpbmcgYXBwbGllZCBiZWZvcmUgdGhlIGJ5dGUtcGFpciBlbmNvZGluZy4gVGhpcyBjYW4gYmUgdXNlZCB0byBlbnN1cmVcbiAgICogc3BlY2lhbCB0b2tlbnMgbWFwIHRvIHVuaXF1ZSBpbmRpY2VzIGluIHRoZSB2b2NhYnVsYXJ5LCBldmVuIGlmIHRoZXNlXG4gICAqIHNwZWNpYWwgdG9rZW5zIGNvbnRhaW4gc3BsaXR0YWJsZSBjaGFyYWN0ZXJzIHN1Y2ggYXMgcHVuY3R1YXRpb24uIFNwZWNpYWxcbiAgICogdG9rZW5zIG11c3Qgc3RpbGwgYmUgaW5jbHVkZWQgaW4gYHZvY2FidWxhcnlgLiBEZWZhdWx0cyB0byBgTm9uZWAuXG4gICAqL1xuICB1bnNwbGl0dGFibGVUb2tlbnM/OiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBCeXRlLXBhaXIgZW5jb2RpbmcgdG9rZW5pemVyIGxheWVyLlxuICpcbiAqIFRoaXMgQlBFIHRva2VuaXplciBwcm92aWRlcyB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5IGFzIHRoZSBvZmZpY2lhbCBHUFQtMlxuICogdG9rZW5pemVyLiBHaXZlbiB0aGUgc2FtZSBgdm9jYWJ1bGFyeWAgd2hpY2ggbWFwcyB0b2tlbnMgdG8gaWRzLCBhbmQgYG1lcmdlc2BcbiAqIHdoaWNoIGRlc2NyaWJlcyBCUEUgbWVyZ2UgcnVsZXMsIGl0IHNob3VsZCBwcm92aWRlIHRoZSBzYW1lIG91dHB1dCBhcyBPcGVuQUlcbiAqIGltcGxlbWVudGF0aW9uIChodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL2dwdC0yL2Jsb2IvbWFzdGVyL3NyYy9lbmNvZGVyLnB5KS5cbiAqXG4gKiBJZiBpbnB1dCBpcyBhIGJhdGNoIG9mIHN0cmluZ3MgKHJhbmsgPiAwKTpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBsYXllciB3aWxsIG91dHB1dCBhIGBUZW5zb3JbXWAuXG4gKiBJZiBgc2VxdWVuY2VMZW5ndGhgIGlzIHNldCwgdGhlIGxheWVyIHdpbGwgb3V0cHV0IGEgYFRlbnNvcltdYCB3aGVyZSBhbGxcbiAqIGlucHV0cyBoYXZlIGJlZW4gcGFkZGVkIG9yIHRydW5jYXRlZCB0byBgc2VxdWVuY2VMZW5ndGhgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIFRva2VuaXplXG4gKiBgYGBqc1xuICogY29uc3Qgdm9jYWJ1bGFyeSA9IG5ldyBNYXAoW1snYnV0dGVyJywgMV0sIFsnZmx5JywgMl1dKTtcbiAqIGNvbnN0IG1lcmdlcyA9IFsnYiB1JywgJ3QgdCcsICdlIHInLCAnYnUgdHQnLCAnYnV0dCBlcicsICdmIGwnLCAnZmwgeSddO1xuICogY29uc3QgdG9rZW5pemVyID0gbmV3IEJ5dGVQYWlyVG9rZW5pemVyKHt2b2NhYnVsYXJ5LCBtZXJnZXN9KTtcbiAqXG4gKiB0b2tlbml6ZXIudG9rZW5pemUodGVuc29yKFsnYnV0dGVyZmx5J10pKVswXS5wcmludCgpO1xuICogdG9rZW5pemVyLnRva2VuaXplKHRlbnNvcihbJ2J1dHRlcmZseSwgYnV0dGVyJ10pKVsxXS5wcmludCgpO1xuICogYGBgXG4gKlxuICogRGV0b2tlbml6ZVxuICogYGBganNcbiAqIGNvbnN0IHZvY2FidWxhcnkgPSBuZXcgTWFwKFtbJ2J1dHRlcicsIDFdLCBbJ2ZseScsIDJdXSk7XG4gKiBjb25zdCBtZXJnZXMgPSBbJ2IgdScsICd0IHQnLCAnZSByJywgJ2J1IHR0JywgJ2J1dHQgZXInLCAnZiBsJywgJ2ZsIHknXTtcbiAqIGNvbnN0IHRva2VuaXplciA9IG5ldyBCeXRlUGFpclRva2VuaXplcih7dm9jYWJ1bGFyeSwgbWVyZ2VzfSk7XG4gKlxuICogdG9rZW5pemVyLmRldG9rZW5pemUoW1sxLCAyXV0pLnByaW50KCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJ5dGVQYWlyVG9rZW5pemVyIGV4dGVuZHMgVG9rZW5pemVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyByZWFkb25seSBjbGFzc05hbWUgPSAnQnl0ZVBhaXJUb2tlbml6ZXInO1xuXG4gIHByaXZhdGUgX3ZvY2FidWxhcnk6IE1hcDxzdHJpbmcsIG51bWJlcj47XG4gIHByaXZhdGUgbWVyZ2VzOiBzdHJpbmdbXTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWRkUHJlZml4U3BhY2U6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgdW5zcGxpdHRhYmxlVG9rZW5zOiBzdHJpbmdbXTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGJ5dGUyVW5pY29kZTogU3RhdGljSGFzaFRhYmxlPG51bWJlciwgc3RyaW5nPjtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZSA9IG5ldyBCeXRlUGFpclRva2VuaXplckNhY2hlKCk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSB0b2tlblRvSWRNYXA6IFN0YXRpY0hhc2hUYWJsZTxzdHJpbmcsIG51bWJlcj47XG4gIHByaXZhdGUgcmVhZG9ubHkgaWRUb1Rva2VuTWFwOiBTdGF0aWNIYXNoVGFibGU8bnVtYmVyLCBzdHJpbmc+O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbWVyZ2VSYW5rc0xvb2t1cERlZmF1bHQ6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBtZXJnZVJhbmtzOiBTdGF0aWNIYXNoVGFibGU8c3RyaW5nLCBudW1iZXI+O1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IEJ5dGVQYWlyVG9rZW5pemVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuXG4gICAgdGhpcy5fdm9jYWJ1bGFyeSA9IG5ldyBNYXAoYXJncy52b2NhYnVsYXJ5KTtcbiAgICB0aGlzLm1lcmdlcyA9IFsuLi5hcmdzLm1lcmdlc107XG5cbiAgICB0aGlzLnNlcXVlbmNlTGVuZ3RoID0gYXJncy5zZXF1ZW5jZUxlbmd0aCB8fCBudWxsO1xuICAgIHRoaXMuYWRkUHJlZml4U3BhY2UgPSBhcmdzLmFkZFByZWZpeFNwYWNlIHx8IGZhbHNlO1xuICAgIHRoaXMudW5zcGxpdHRhYmxlVG9rZW5zID0gYXJncy51bnNwbGl0dGFibGVUb2tlbnMgfHwgbnVsbDtcblxuICAgIC8vIENyZWF0ZSBieXRlIDw9PiB1bmljb2RlIG1hcHBpbmcuIFRoaXMgaXMgdXNlZnVsIGZvciBoYW5kbGluZ1xuICAgIC8vIHdoaXRlc3BhY2UgdG9rZW5zLlxuICAgIGNvbnN0IFtieXRlTGlzdCwgdW5pY29kZUxpc3RdID0gYnl0ZXNUb1VuaWNvZGUoKTtcbiAgICB0aGlzLmJ5dGUyVW5pY29kZSA9IGNyZWF0ZVN0YXRpY0hhc2h0YWJsZShcbiAgICAgIEFycmF5LmZyb20oYnl0ZUxpc3QpLCB1bmljb2RlTGlzdCwgJycpO1xuXG4gICAgaWYgKHRoaXMudW5zcGxpdHRhYmxlVG9rZW5zKSB7XG4gICAgICAvLyBQdXQgdW5zcGxpdHRhYmxlIHRva2VucyBpbnRvIGNhY2hlLCBzbyBpdCB3b24ndCBiZSBmdXJ0aGVyIHNwbGl0IGFuZFxuICAgICAgLy8gbWVyZ2VkLlxuICAgICAgdGhpcy5jYWNoZS5pbnNlcnQodGhpcy51bnNwbGl0dGFibGVUb2tlbnMsIHRoaXMudW5zcGxpdHRhYmxlVG9rZW5zKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbWFwcGluZyBiZXR3ZWVuIHN0cmluZyB0b2tlbnMgdG8gaW50IGlkcywgYW5kIHZpY2UgdmVyc2EuXG4gICAgY29uc3QgYnl0ZVBhaXJzID0gWy4uLnRoaXMuX3ZvY2FidWxhcnkua2V5cygpXTtcbiAgICBjb25zdCBieXRlUGFpckVuY29kaW5nSW5kaWNpZXMgPSBbLi4udGhpcy5fdm9jYWJ1bGFyeS52YWx1ZXMoKV07XG5cbiAgICB0aGlzLnRva2VuVG9JZE1hcCA9IGNyZWF0ZVN0YXRpY0hhc2h0YWJsZShcbiAgICAgIGJ5dGVQYWlycywgYnl0ZVBhaXJFbmNvZGluZ0luZGljaWVzLCAtMSk7XG5cbiAgICB0aGlzLmlkVG9Ub2tlbk1hcCA9IGNyZWF0ZVN0YXRpY0hhc2h0YWJsZShcbiAgICAgIGJ5dGVQYWlyRW5jb2RpbmdJbmRpY2llcywgYnl0ZVBhaXJzLCAnJyk7XG5cbiAgICAvLyBDcmVhdGUgcmFua2luZyBvZiBtZXJnZSBydWxlcywgdGhpcyBpcyB0aGUgc2FtZSBhcyBvcmRlciBvZiBtZXJnZSBwYWlyc1xuICAgIC8vIGluIGB0aGlzLm1lcmdlc2AuXG4gICAgdGhpcy5tZXJnZVJhbmtzTG9va3VwRGVmYXVsdCA9IHRoaXMubWVyZ2VzLmxlbmd0aCArIDE7XG4gICAgdGhpcy5tZXJnZVJhbmtzID0gY3JlYXRlU3RhdGljSGFzaHRhYmxlKFxuICAgICAgdGhpcy5tZXJnZXMsXG4gICAgICBbLi4uQXJyYXkodGhpcy5tZXJnZXMubGVuZ3RoKS5rZXlzKCldLFxuICAgICAgdGhpcy5tZXJnZVJhbmtzTG9va3VwRGVmYXVsdFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0b2tlbml6ZXIgdm9jYWJ1bGFyeSBhcyBhIGxpc3Qgb2Ygc3RyaW5nIHRva2Vucy5cbiAgICovXG4gIG92ZXJyaWRlIGdldCB2b2NhYnVsYXJ5KCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3ZvY2FidWxhcnkua2V5cygpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRva2VuaXplciB2b2NhYnVsYXJ5LlxuICAgKi9cbiAgb3ZlcnJpZGUgZ2V0IHZvY2FidWxhcnlTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZvY2FidWxhcnkuc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIGludGVnZXIgaWQgdG8gYSBzdHJpbmcgdG9rZW4uXG4gICAqL1xuICBvdmVycmlkZSBpZFRvVG9rZW4oaWQ6IG51bWJlcik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgLy8gVGhpcyB3aWxsIGJlIHNsb3csIGJ1dCBrZWVwIG1lbW9yeSB1c2FnZSBkb3duIGNvbXBhcmVkIHRvIGJ1aWxkaW5nIGFcbiAgICAvLyBkaWN0LiBBc3N1bWluZyB0aGUgbWFpbiB1c2UgY2FzZSBpcyBsb29raW5nIHVwIGEgZmV3IHNwZWNpYWwgdG9rZW5zXG4gICAgLy8gZWFybHkgaW4gdGhlIHZvY2FiLCB0aGlzIHNob3VsZCBiZSBmaW5lLlxuICAgIGNvbnN0IGtleXMgPSB0aGlzLnZvY2FidWxhcnk7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBrZXlzKSB7XG4gICAgICBpZiAodGhpcy5fdm9jYWJ1bGFyeS5nZXQodG9rZW4pID09PSBpZCkge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHN0cmluZyB0b2tlbiB0byBhbiBpbnRlZ2VyIGlkLlxuICAgKi9cbiAgb3ZlcnJpZGUgdG9rZW5Ub0lkKHRva2VuOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl92b2NhYnVsYXJ5LmdldCh0b2tlbik7XG4gIH1cblxuICBvdmVycmlkZSBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICB2b2NhYnVsYXJ5OiB0aGlzLnZvY2FidWxhcnksXG4gICAgICBtZXJnZXM6IHRoaXMubWVyZ2VzLFxuICAgICAgc2VxdWVuY2VMZW5ndGg6IHRoaXMuc2VxdWVuY2VMZW5ndGgsXG4gICAgICBhZGRQcmVmaXhTcGFjZTogdGhpcy5hZGRQcmVmaXhTcGFjZSxcbiAgICAgIHVuc3BsaXR0YWJsZVRva2VuczogdGhpcy51bnNwbGl0dGFibGVUb2tlbnMsXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBvbmUgc3RlcCBvZiBieXRlLXBhaXIgbWVyZ2UuXG4gICAqL1xuICBwcml2YXRlIGJwZU1lcmdlT25lU3RlcChcbiAgICB3b3JkczogVGVuc29yW10sIG1hc2s6IGJvb2xlYW5bXSk6IFtUZW5zb3JbXSwgYm9vbGVhbltdXSB7XG5cbiAgICBjb25zdCB3b3Jkc1N0ciA9IHRlbnNvckFyclRvMkRBcnIod29yZHMpIGFzIHN0cmluZ1tdW107XG5cbiAgICAvLyBHZXQgYWxsIHdvcmQgcGFpcnMuXG4gICAgY29uc3QgZmlyc3QgPSB3b3Jkc1N0ci5tYXAoYXJyID0+IGFyci5zbGljZSgwLCAtMSkpO1xuICAgIGNvbnN0IHNlY29uZCA9IHdvcmRzU3RyLm1hcChhcnIgPT4gYXJyLnNsaWNlKDEsIGFyci5sZW5ndGgpKTtcblxuICAgIC8vIE1hc2sgZW1wdHkuXG4gICAgY29uc3Qgbm9uRW1wdHlNYXNrID0gc2Vjb25kLm1hcChhcnIgPT4gYXJyLmxlbmd0aCA+IDApO1xuICAgIG1hc2sgPSBtYXNrLm1hcCgoYSwgaWR4KSA9PiBhICYmIG5vbkVtcHR5TWFza1tpZHhdKTtcbiAgICBpZiAoIW1hc2suc29tZShlID0+IGUpKSB7XG4gICAgICByZXR1cm4gW3dvcmRzLCBtYXNrXTtcbiAgICB9XG4gICAgY29uc3Qgbm9uRW1wdHlJbmRpY2VzID0gbWFza1xuICAgICAgLm1hcCgoYm9vbCwgaWR4KSA9PiBib29sID8gaWR4IDogLTEpXG4gICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gLTEpO1xuXG4gICAgY29uc3QgZmlsdGVyZWRGaXJzdCA9IG5vbkVtcHR5SW5kaWNlcy5tYXAoaWR4ID0+IGZpcnN0W2lkeF0pO1xuICAgIGNvbnN0IGZpbHRlcmVkU2Vjb25kID0gbm9uRW1wdHlJbmRpY2VzLm1hcChpZHggPT4gc2Vjb25kW2lkeF0pO1xuXG4gICAgLy8gR2V0IGJ5dGUgcGFpciByYW5raW5nIGluIG1lcmdlIHJ1bGVzLlxuICAgIGNvbnN0IHBhaXJzOiBzdHJpbmdbXVtdID0gZmlsdGVyZWRGaXJzdC5tYXAoKGZpcnN0U3ViQXJyLCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IHNlY29uZFN1YkFyciA9IGZpbHRlcmVkU2Vjb25kW2lkeF07XG5cbiAgICAgIHJldHVybiBmaXJzdFN1YkFyci5tYXAoKGNoYXIsIGlkeCkgPT4gYCR7Y2hhcn0gJHtzZWNvbmRTdWJBcnJbaWR4XX1gKTtcbiAgICB9KTtcbiAgICBjb25zdCBwYWlyUmFua3NUZW5zb3IgPSB0aGlzLm1lcmdlUmFua3MubG9va3VwKFxuICAgICAgcGFpcnMubWFwKGFyciA9PiB0ZW5zb3IoYXJyKSkpO1xuICAgIGNvbnN0IHBhaXJSYW5rcyA9IHRlbnNvckFyclRvMkRBcnIocGFpclJhbmtzVGVuc29yKSBhcyBudW1iZXJbXVtdO1xuXG4gICAgLy8gR2V0IEJQRSBwYWlyIHJhbmtzLlxuICAgIGNvbnN0IG1pblBhaXJSYW5rID0gcGFpclJhbmtzLm1hcChcbiAgICAgIGFyciA9PiBhcnIucmVkdWNlKChhLCBiKSA9PiBNYXRoLm1pbihhLCBiKSwgSW5maW5pdHkpKTtcbiAgICBjb25zdCBwYWlyRm91bmRNYXNrID0gbWluUGFpclJhbmsubWFwKFxuICAgICAgcmFuayA9PiByYW5rICE9PSB0aGlzLm1lcmdlUmFua3NMb29rdXBEZWZhdWx0KTtcblxuICAgIC8vIFRva2VucyB0aGF0IGNhbm5vdCBiZSBmdXJ0aGVyIG1lcmdlZCBhcmUgbWFya2VkIGFzIGZpbmlzaGVkLlxuICAgIGZvciAoY29uc3QgW2lkeCwgaW5kZXhdIG9mIG5vbkVtcHR5SW5kaWNlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IHBhaXJGb3VuZE1hc2tbaWR4XTtcbiAgICAgIG1hc2tbaW5kZXhdID0gdXBkYXRlO1xuICAgIH1cbiAgICBpZiAoIW1hc2suc29tZShlID0+IGUpKSB7XG4gICAgICByZXR1cm4gW3dvcmRzLCBtYXNrXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcmdNaW4oYXJyOiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgICByZXR1cm4gYXJyLmluZGV4T2YoYXJyLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksIEluZmluaXR5KSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFza2VkUGFpclJhbmtzID0gcGFpclJhbmtzLmZpbHRlcigoXywgaWR4KSA9PiBwYWlyRm91bmRNYXNrW2lkeF0pO1xuICAgIGNvbnN0IG1pblBhaXJSYW5rSW5kaWNlcyA9IG1hc2tlZFBhaXJSYW5rcy5tYXAoYXJyID0+IGFyZ01pbihhcnIpKTtcblxuICAgIC8vIEdldCB3b3JkcyBhbmQgcGFpcnMgdG8gcHJvY2Vzcy5cbiAgICBjb25zdCB1bmZpbmlzaGVkV29yZHMgPSB3b3Jkc1N0ci5maWx0ZXIoKF8sIGlkeCkgPT4gbWFza1tpZHhdKTtcblxuICAgIGNvbnN0IHBhaXJMZWZ0ID0gdW5maW5pc2hlZFdvcmRzLm1hcChcbiAgICAgICh3b3JkLCBpZHgpID0+IHdvcmRbbWluUGFpclJhbmtJbmRpY2VzW2lkeF1dKTtcblxuICAgIGNvbnN0IHBhaXJSaWdodCA9IHVuZmluaXNoZWRXb3Jkcy5tYXAoXG4gICAgICAod29yZCwgaWR4KSA9PiB3b3JkW21pblBhaXJSYW5rSW5kaWNlc1tpZHhdICsgMV0pO1xuXG4gICAgY29uc3QgbWVyZ2VkUGFpcnMgPSBwYWlyTGVmdC5tYXAoKGxlZnQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcmlnaHQgPSBwYWlyUmlnaHRbaWR4XTtcbiAgICAgIHJldHVybiBgJHtsZWZ0fSR7cmlnaHR9YDtcbiAgICB9KTtcbiAgICBjb25zdCB1bmZpbmlzaGVkV29yZHNJbmRpY2VzID0gbWFza1xuICAgICAgLm1hcCgoXywgaWR4KSA9PiBpZHgpXG4gICAgICAuZmlsdGVyKChfLCBpZHgpID0+IG1hc2tbaWR4XSk7XG5cbiAgICBjb25zdCBtZXJnZWRQYWlySW5kaWNlcyA9IHVuZmluaXNoZWRXb3Jkc0luZGljZXMubWFwKFxuICAgICAgKGluZGV4LCBpZHgpID0+IFtpbmRleCwgbWluUGFpclJhbmtJbmRpY2VzW2lkeF1dKTtcbiAgICBjb25zdCBlbXB0eVN0cmluZ0luZGljZXMgPSB1bmZpbmlzaGVkV29yZHNJbmRpY2VzLm1hcChcbiAgICAgIChpbmRleCwgaWR4KSA9PiBbaW5kZXgsIG1pblBhaXJSYW5rSW5kaWNlc1tpZHhdICsgMV0pO1xuXG4gICAgZm9yIChjb25zdCBbaWR4LCBpbmRpY2VzXSBvZiBtZXJnZWRQYWlySW5kaWNlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IFt3b3JkSWR4LCBjaGFySWR4XSA9IGluZGljZXM7XG4gICAgICBjb25zdCBtZXJnZWRQYWlyID0gbWVyZ2VkUGFpcnNbaWR4XTtcbiAgICAgIHdvcmRzU3RyW3dvcmRJZHhdW2NoYXJJZHhdID0gbWVyZ2VkUGFpcjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGluZGljZXMgb2YgZW1wdHlTdHJpbmdJbmRpY2VzKSB7XG4gICAgICBjb25zdCBbd29yZElkeCwgY2hhcklkeF0gPSBpbmRpY2VzO1xuICAgICAgd29yZHNTdHJbd29yZElkeF1bY2hhcklkeF0gPSAnJztcbiAgICB9XG5cbiAgICB3b3JkcyA9IHdvcmRzU3RyLm1hcCh3b3JkID0+IHRlbnNvcih3b3JkKSk7XG4gICAgd29yZHMgPSByZW1vdmVTdHJpbmdzRnJvbUlucHV0cyh3b3JkcywgJycpO1xuXG4gICAgcmV0dXJuIFt3b3JkcywgbWFza107XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBieXRlLXBhaXIgbWVyZ2UgZm9yIGVhY2ggd29yZCBpbiB0aGUgaW5wdXRzLlxuICAgKi9cbiAgcHJpdmF0ZSBicGVNZXJnZSh3b3JkczogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3QgbnVtV29yZHMgPSB3b3Jkcy5sZW5ndGg7XG5cbiAgICAvLyBNZXJnZSBieXRlcy5cbiAgICBmdW5jdGlvbiBsb29wQ29uZGl0aW9uKG1hc2s6IGJvb2xlYW5bXSk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIG1hc2suc29tZShlID0+IGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWxNYXNrOiBib29sZWFuW10gPSBBcnJheShudW1Xb3JkcykuZmlsbCh0cnVlKTtcblxuICAgIGxldCBtZXJnZWRXb3JkcyA9IHdvcmRzO1xuICAgIGxldCBtYXNrID0gaW5pdGlhbE1hc2s7XG4gICAgd2hpbGUgKGxvb3BDb25kaXRpb24obWFzaykpIHtcbiAgICAgIFttZXJnZWRXb3JkcywgbWFza10gPSB0aGlzLmJwZU1lcmdlT25lU3RlcChtZXJnZWRXb3JkcywgbWFzayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZFdvcmRzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcCB0b2tlbiBieXRlcyB0byB1bmljb2RlIHVzaW5nIGBieXRlMnVuaWNvZGVgLlxuICAgKi9cbiAgcHJpdmF0ZSB0cmFuc2Zvcm1CeXRlcyh0b2tlbnM6IFRlbnNvcik6IFRlbnNvcltdIHtcbiAgICBjb25zdCB0b2tlbnNTdHIgPSB0ZW5zb3JUb0Fycih0b2tlbnMpIGFzIHN0cmluZ1tdO1xuXG4gICAgY29uc3Qgc3BsaXRCeXRlcyA9IHRva2Vuc1N0ci5tYXAoXG4gICAgICB0b2tlbiA9PiB0ZW5zb3IodG9rZW4uc3BsaXQoJycpLm1hcChjID0+IGMuY2hhckNvZGVBdCgwKSkpKTtcbiAgICBjb25zdCBzcGxpdFVuaWNvZGUgPSB0aGlzLmJ5dGUyVW5pY29kZS5sb29rdXAoc3BsaXRCeXRlcyk7XG5cbiAgICByZXR1cm4gc3BsaXRVbmljb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdW5zZWVuIHRva2VucyBhbmQgYWRkIHRvIGNhY2hlLlxuICAgKi9cbiAgcHJpdmF0ZSBicGVNZXJnZUFuZFVwZGF0ZUNhY2hlKHRva2VuczogVGVuc29yKSB7XG4gICAgY29uc3Qgd29yZHMgPSB0aGlzLnRyYW5zZm9ybUJ5dGVzKHRva2Vucyk7XG4gICAgY29uc3QgdG9rZW5pemVkV29yZHNUZW5zb3IgPSB0aGlzLmJwZU1lcmdlKHdvcmRzKTtcbiAgICBjb25zdCB0b2tlbml6ZWRXb3JkcyA9IHRlbnNvckFyclRvMkRBcnIodG9rZW5pemVkV29yZHNUZW5zb3IpIGFzIHN0cmluZ1tdW107XG5cbiAgICAvLyBGb3IgZWFjaCB3b3JkLCBqb2luIGFsbCBpdHMgdG9rZW4gYnkgYSB3aGl0ZXNwYWNlLFxuICAgIC8vIGUuZy4sIFtcImRyYWdvblwiLCBcImZseVwiXSA9PiBcImRyYWdvbiBmbHlcIiBmb3IgaGFzaCBwdXJwb3NlLlxuICAgIGNvbnN0IGpvaW5lZFRva2VucyA9IHRva2VuaXplZFdvcmRzLm1hcCh3b3JkID0+IHdvcmQuam9pbignICcpKTtcblxuICAgIHRoaXMuY2FjaGUuaW5zZXJ0KHRva2Vucywgam9pbmVkVG9rZW5zKTtcbiAgfVxuXG4gIHRva2VuaXplKGlucHV0czogVGVuc29yKTogVGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmFkZFByZWZpeFNwYWNlKSB7XG4gICAgICAgIGNvbnN0IHN0cklucHV0cyA9IHRlbnNvclRvQXJyKGlucHV0cykgYXMgc3RyaW5nW107XG4gICAgICAgIGlucHV0cyA9IHRlbnNvcihzdHJJbnB1dHMubWFwKHdvcmQgPT4gJyAnICsgd29yZCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByYXdUb2tlbnNUZW5zb3IgPVxuICAgICAgICBzcGxpdFN0cmluZ3NGb3JCcGUoaW5wdXRzLCB0aGlzLnVuc3BsaXR0YWJsZVRva2Vucyk7XG4gICAgICBjb25zdCByYXdUb2tlbnMgPSB0ZW5zb3JBcnJUbzJEQXJyKHJhd1Rva2Vuc1RlbnNvcikgYXMgc3RyaW5nW11bXTtcblxuICAgICAgY29uc3QgdG9rZW5Sb3dTcGxpdHMgPSBbMF07XG4gICAgICBmb3IgKGNvbnN0IFtpZHgsIHRva2VuXSBvZiByYXdUb2tlbnMuZW50cmllcygpKSB7XG4gICAgICAgIHRva2VuUm93U3BsaXRzLnB1c2godG9rZW5Sb3dTcGxpdHNbaWR4XSArIHRva2VuLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZsYXRUb2tlbnMgPSByYXdUb2tlbnMucmVkdWNlKChhY2MsIGUpID0+IGFjYy5jb25jYXQoZSksIFtdKTtcblxuICAgICAgLy8gQ2hlY2sgY2FjaGUuXG4gICAgICBjb25zdCBjYWNoZUxvb2t1cCA9IHRoaXMuY2FjaGUubG9va3VwKGZsYXRUb2tlbnMpO1xuICAgICAgY29uc3QgY2FjaGVNYXNrID0gY2FjaGVMb29rdXAubWFwKGUgPT4gZSA9PT0gJycpO1xuXG4gICAgICBjb25zdCBoYXNVbnNlZW5Xb3JkcyA9IGNhY2hlTWFzay5zb21lKFxuICAgICAgICAoYm9vbCwgaWR4KSA9PiBib29sICYmIGZsYXRUb2tlbnNbaWR4XSAhPT0gJycpO1xuXG4gICAgICBjb25zdCBwcm9jZXNzVW5zZWVuVG9rZW5zID0gKCk6IHN0cmluZ1tdICA9PiB7XG4gICAgICAgIGNvbnN0IHVuc2VlblRva2VucyA9IGZsYXRUb2tlbnMuZmlsdGVyKChfLCBpZHgpID0+IGNhY2hlTWFza1tpZHhdKTtcbiAgICAgICAgdGhpcy5icGVNZXJnZUFuZFVwZGF0ZUNhY2hlKHRlbnNvcih1bnNlZW5Ub2tlbnMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUubG9va3VwKGZsYXRUb2tlbnMpO1xuICAgICAgfTtcblxuICAgICAgLy8gSWYgYGhhc191bnNlZW5fd29yZHMgPT0gVHJ1ZWAsIGl0IG1lYW5zIG5vdCBhbGwgdG9rZW5zIGFyZSBpbiBjYWNoZSxcbiAgICAgIC8vIHdlIHdpbGwgcHJvY2VzcyB0aGUgdW5zZWVuIHRva2Vucy4gT3RoZXJ3aXNlIHJldHVybiB0aGUgY2FjaGUgbG9va3VwLlxuICAgICAgY29uc3QgdG9rZW5pemVkV29yZHMgPVxuICAgICAgICBoYXNVbnNlZW5Xb3JkcyA/IHByb2Nlc3NVbnNlZW5Ub2tlbnMoKSA6IGNhY2hlTG9va3VwO1xuXG4gICAgICBjb25zdCB0b2tlbnNUZW5zb3IgPSB0aGlzLnRva2VuVG9JZE1hcC5sb29rdXAoXG4gICAgICAgIHRva2VuaXplZFdvcmRzLm1hcCh3b3JkID0+IHRlbnNvcih3b3JkLnNwbGl0KCcgJykpKSk7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbnNUZW5zb3IubWFwKHQgPT4gQXJyYXkuZnJvbSh0LmRhdGFTeW5jKCkpKTtcblxuICAgICAgLy8gVW5mbGF0dGVuIHRvIG1hdGNoIGlucHV0LlxuICAgICAgY29uc3QgbmV3VG9rZW5Sb3dTcGxpdHMgPSBbMF07XG4gICAgICBmb3IgKGNvbnN0IFtpZHgsIHRva2VuXSBvZiB0b2tlbnMuZW50cmllcygpKSB7XG4gICAgICAgIG5ld1Rva2VuUm93U3BsaXRzLnB1c2gobmV3VG9rZW5Sb3dTcGxpdHNbaWR4XSArIHRva2VuLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdGbGF0VG9rZW5zID0gdG9rZW5zLnJlZHVjZSgoYWNjLCBlKSA9PiBhY2MuY29uY2F0KGUpLCBbXSk7XG4gICAgICBjb25zdCBnYXRoZXJlZEluZGljZXMgPVxuICAgICAgICB0b2tlblJvd1NwbGl0cy5tYXAoaW5kZXggPT4gbmV3VG9rZW5Sb3dTcGxpdHNbaW5kZXhdKTtcblxuICAgICAgbGV0IHRva2VuczJEOiBUZW5zb3JbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYXRoZXJlZEluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IFtnYXRoZXJlZEluZGljZXNbaV0sIGdhdGhlcmVkSW5kaWNlc1tpKzFdXTtcbiAgICAgICAgY29uc3Qgcm93ID0gbmV3RmxhdFRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgdG9rZW5zMkQucHVzaCh0ZW5zb3Iocm93KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgdG8gYSBkZW5zZSBvdXRwdXQgaWYgYHNlcXVlbmNlTGVuZ3RoYCBpcyBzZXQuXG4gICAgICBpZiAodGhpcy5zZXF1ZW5jZUxlbmd0aCkge1xuICAgICAgICAvLyBwYWQgb3IgdHJ1bmNhdGVcbiAgICAgICAgdG9rZW5zMkQgPSB0b2tlbnMyRC5tYXAodCA9PiB7XG4gICAgICAgICAgaWYgKHQuc2l6ZSA9PT0gdGhpcy5zZXF1ZW5jZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0LnNpemUgPiB0aGlzLnNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5zbGljZSgwLCB0aGlzLnNlcXVlbmNlTGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHQucGFkKFtbMCwgdGhpcy5zZXF1ZW5jZUxlbmd0aCAtIHQuc2l6ZV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW5zMkQ7XG4gICAgfSk7XG4gIH1cblxuICBvdmVycmlkZSBkZXRva2VuaXplKGlucHV0czogVGVuc29yW10pOiBUZW5zb3Ige1xuICAgIGNvbnN0IHVuaWNvZGVUZXh0ID0gdGhpcy5pZFRvVG9rZW5NYXAubG9va3VwKGlucHV0cylcbiAgICAgIC5tYXAodCA9PiAodGVuc29yVG9BcnIodCkgYXMgc3RyaW5nW10pLmpvaW4oJycpKTtcblxuICAgIHJldHVybiB0ZW5zb3IodW5pY29kZVRleHQpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQnl0ZVBhaXJUb2tlbml6ZXIpO1xuIl19